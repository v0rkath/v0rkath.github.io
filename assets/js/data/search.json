[ { "title": "How IAT Hooking Works", "url": "/posts/How-IAT-Hooking-Works/", "categories": "Reverse Engineering, Hooking, Hacking", "tags": "hooking, hook, hacking, IAT, ILT, IDT", "date": "2022-12-20 14:15:00 +0000", "snippet": "OverviewThis method of hooking is done by changing the address of the function you want to hook in the IAT so it jumps to your code rather than the function.What is IDT, IAT &amp; ILT?The IDT is an acronym for ‘Import Directory Table’, this contains an array of IMAGE_IMPORT_DESCRIPTOR structs. This is usually found at the beginning of the .idata section of a binary (sometimes you may find it in .rdata). These structs are used for each imported DLL to the process. The IMAGE_IMPORT_DESCRIPTOR structs are laid out like so:typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA to the ILT/INT } DUMMYUNIONNAME; DWORD TimeDateStamp; /* 0 if not bound, -1 if bound, and real date\\time stamp in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) O.W. date/time stamp of DLL bound to (Old BIND) */ DWORD ForwarderChain; // -1 if no forwarders DWORD Name; DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses).} IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;The main things in the above struct that are mainly used for IAT Hooking at the OriginalFirstThunk (The relative virtual address to the ILT/INT), Name (name of the DLL) and FirstThunk (the relative virtual address to the IAT).Fig 1. General relationship of the Import Directory, IAT and ILTThe ILT/INT is an acronym for either Import Lookup Table or Import Name Table, respectively. Both of which are names which are used interchangeably. The is a table of function names which have been imported into the process by the DLL. As just mentioned above the IMAGE_IMPORT_DESCRIPTOR contains the address of the ILT/INT.IAT stands for Import Address Table, so it pretty much does what it says on the tin; it’s a table of addresses for each imported function. However, on disk the IAT is identical to the ILT (so it just holds the names of the functions), but at runtime the loader overwrites the IAT with the addresses of those functions.Fig 2. IAT &amp; ILT on disk and at runtimeI believe this is all you really need to know to understand how this hooking technique works.How does IAT Hooking work?This is relatively simple and has been used in various bits of malware for various purposes, some of which are: Stop a function from running Extract information from the function Simply just running additional code whenever the original function is calledFig 3. Example of how the IAT looks after it has hooked CreateFileW. It now has the address of our code rather than the address of CreateFileW which you can see in Fig 2Once you have found the IAT and the function to hook, the process is the following: Change the address of the function in the IAT to the address of your own code, by doing this whenever that function is called it will go to your own code rather than the actual function. This will then run your own code and then you can jump to the original function to run it.Issues with IAT Hooking It is quite easy to detect this type of hooking as each imported function comes from another binary (example: kernel32.dll) and these have bounds in memory, so if the function address is changed in IAT to an address outside of the bounds then you know it’s not the original function and something funky is going on. If the import is imported via ordinal then you won’t be able to do this type of hooking." }, { "title": "Basics of Hooking Functions", "url": "/posts/How-Hooking-Works/", "categories": "Reverse Engineering, Hooking, Hacking", "tags": "hooking, hook, hacking", "date": "2022-12-10 22:00:00 +0000", "snippet": "OverviewThis blog post is to provide a very basic overview of what a hook is and the general process of how it works. Hooks are used to ensure your code is run when a certain function of a process is run. For this blog post we are going to be using the scenario of your player character being damaged in game. So, we want to run our own code every time the player’s health decreases, this allows us to do many fun things within a process.Hooking is used quite a lot in certain malware (for instance to steal login information from a binary despite the password being hidden via asterisks), game hacking and also enhancing the functionality of a program.The general process of hooking a function Find the function you want to hook into (whenever the function will be run, your own code will run). Change certain instruction(s) to jump to your own code. Run your own code and any collateral instruction(s) which have been overwriten for the jump instruction in step 2. Make sure your own code jumps back to the instruction after your jump in the hooked function.Here is an image example of a very basic hook into part of a function which subtracts damage from our player’s health. In order to place our own code into a process we can inject a DLL into the process by using an injector (Guided Hacking’s Injector is pretty good) and then using a function like VirtualProtect() to change the protection of the function you want to hook to then to overwrite bytes for the jump to your own code.Additional ResourcesIf you’re interesting in learning how to do this rather than the theory behind it then I recommend watching/reading the following resources: Video: C++ How to Detour / Hook Functions Tutorial Video: How Function Hooking / Detouring Works Guide: How to Hook Functions - Code Detouring Guide" }, { "title": "RC4 (Rivest Cipher 4) - How it operates & how to recognise it", "url": "/posts/sdfsdf/", "categories": "Reverse Engineering, Encryption/Decryption", "tags": "encryption, decryption, rc4", "date": "2022-08-01 10:00:00 +0000", "snippet": "RC4 (Rivest Cipher 4)This is a very commonly used Stream Cipher (this transforms a plaintext string byte-by-byte, they are linear meaning they are a symmetric type of encryption).Typically has 3 stages: Key Scheduling Algorithm (KSA) -&gt; Creates a list of scrambled values Creates a list of values form 0 to 256 Each value is swapped with another based on a calculation (essentially scrambles the list of values) Pseudo Random Generation Algorithm (PRGA) -&gt; Creates the Keystream Generates and outputs the Keystream using the list It will generate however many bytes it needs (up to 256) The value ‘256’ or ‘0x100’ is often an easy way to work out that the encryption may be RC4 in assembly. XOR Operation -&gt; Encrypts plaintext string using the Keystream It XOR’s each byte of the Plaintext with a byte from the Keystream Recognising RC4When looking through assembly you should be able to spot the following which may give you an indication that it is using RC4: The use of 256 and 0x100 constants in assembly Recognising the 3 stages of RC4" } ]
